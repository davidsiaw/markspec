#!/usr/bin/env ruby

require 'markspec'
require 'fileutils'
require 'yaml'
require 'open3'

files = [ARGV[0]]
files = Dir['spec/**/*.md'] if files.first.nil?

CUTTER_REGEX = /^(?<front>(```|~~~)[a-z0-9]+).+/.freeze

def preprocess_file(file)
  contents = File.read file

  contexts = []
  blocks = []

  lines = contents.split "\n"
  inside_type = false
  current_block = []

  nlines = lines.map do |line|
    # if inside_type
    #   puts "#{inside_type} #{line}"
    # else
    #   puts "    #{line}"
    # end

    if line[0..2] == inside_type
      inside_type = false
      blocks << current_block.join("\n")
      current_block = []
    else
      current_block << line if inside_type
    end

    if !inside_type
      line.gsub(CUTTER_REGEX) do |m|
        contexts << m
        matched = CUTTER_REGEX.match(m)
        inside_type = matched[:front][0..2]

        matched[:front]
      end
    else
      line
    end
  end

  { raw: nlines.join("\n"), contexts: contexts, blocks: blocks }
end

# a test case
class TestCase
  attr_reader :expected, :matcher

  def initialize(cmds)
    @expectations = []
    @prep = []
    @commands = []
    @cmds = cmds
    parse!
  end

  def pass?
    @pass ||= begin
      execute!
      @result ? true : false
    end
  end

  private

  def execute!
    @prep.each do |info|
      File.write(info[:file], info[:content])
    end

    @result = true

    @commands.each_with_index do |block, index|
      begin
        stdout, stderr, status = Open3.capture3(block)
        info = @expectations[index]
        matched_result = case info[:thing]
                         when /^file:(.+)/
                           File.read($1).chomp
                         when 'stdout'
                           stdout
                         when 'stderr'
                           stderr
                         when 'exitcode'
                           status.exitstatus.to_s
                         end

        @result &&= case info[:type]
                    when 'regex'
                      Regexp.new(info[:content].chomp) =~ matched_result
                    else
                      matched_result.chomp == info[:content].chomp
                    end

      rescue StandardError => _e
        @result = false
      end
    end

    nil
  end

  def parse!
    @cmds.each do |annotation, block|
      x = CUTTER_REGEX.match(annotation)
      command = annotation.sub(/^#{x[:front]}\s+/, '')

      case command
      when /^file:(.+)/
        @prep << { file: $1, content: block }
      when /^command/
        @commands << block
      when /^expected (.+)/
        @expectations << {
          thing: $1,
          content: block || '',
          type: x[:front][3..-1]
        }
      end
    end
  end
end

cases = []
files.each do |file|
  info = preprocess_file file
  cmds = info[:contexts].zip(info[:blocks])
  print "Test: #{file} - "
  tc = TestCase.new(cmds)
  if tc.pass?
    puts 'pass'
  else
    puts 'fail'
  end
  cases << tc
end
